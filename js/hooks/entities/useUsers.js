// Hook personnalis√© pour la gestion des utilisateurs
function useUsers() {
    const { useState, useEffect, useCallback } = React;
    const supabase = window.supabaseConfig.client;
    
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    const fetchUsers = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);
            
            const { data, error: fetchError } = await supabase
                .from('user_profile')
                .select(`
                    *,
                    entreprise:entreprise_id(id, nom, type_entreprise),
                    service:service_id(id, nom),
                    fonction:fonction_id(id, nom),
                    user_competence!user_id(
                        id,
                        niveau,
                        logiciel:logiciel_id(
                            id,
                            nom,
                            logo
                        )
                    )
                `)
                .order('created_at', { ascending: false });
            
            if (fetchError) throw fetchError;
            
            // RLS g√®re maintenant le filtrage automatiquement
            // Plus besoin de filtrer c√¥t√© frontend
            setUsers(data || []);
        } catch (err) {
            console.error('Erreur lors du chargement des utilisateurs:', err);
            setError(err.message);
        } finally {
            setLoading(false);
        }
    }, []);
    
    const createUser = async (user) => {
        try {
            setError(null);
            const { data, error: insertError } = await supabase
                .from('user_profile')
                .insert(user)
                .select()
                .single();
            
            if (insertError) throw insertError;
            await fetchUsers();
            return data;
        } catch (err) {
            console.error('Erreur lors de la cr√©ation:', err);
            setError(err.message);
            throw err;
        }
    };
    
    const createUserWithAuth = async (userData) => {
        try {
            setError(null);
            
            console.log('üîÑ D√©but cr√©ation utilisateur:', { email: userData.email, nom: userData.nom, prenom: userData.prenom });
            
            // Extraire email et password des donn√©es
            const { email, password, ...profileData } = userData;
            
            if (!email || !password) {
                throw new Error('Email et mot de passe sont requis');
            }
            
            console.log('üìß Donn√©es profil √† ins√©rer:', profileData);
            
            // Cr√©er d'abord le compte auth avec confirmation d√©sactiv√©e
            console.log('üîê Cr√©ation compte auth...');
            const { data: authData, error: authError } = await supabase.auth.signUp({
                email: email,
                password: password,
                options: {
                    emailRedirectTo: window.location.origin,
                    data: {
                        email_confirm: false
                    }
                }
            });
            
            if (authError) {
                console.error('‚ùå Erreur auth:', authError);
                if (authError.message.includes('already registered')) {
                    throw new Error('Cet email est d√©j√† utilis√©');
                }
                throw authError;
            }
            
            if (!authData.user) {
                console.error('‚ùå Pas de donn√©es utilisateur retourn√©es');
                throw new Error('Erreur lors de la cr√©ation du compte');
            }
            
            console.log('‚úÖ Compte auth cr√©√©:', authData.user.id);
            
            // Cr√©er le profil avec le m√™me ID que le compte auth
            console.log('üë§ Cr√©ation profil utilisateur...');
            const { data: profileDataResult, error: profileError } = await supabase
                .from('user_profile')
                .insert({
                    ...profileData,
                    id: authData.user.id,
                    email: email  // Stocker l'email dans user_profile aussi
                })
                .select()
                .single();
            
            if (profileError) {
                console.error('‚ùå Erreur profil:', profileError);
                console.log('üóëÔ∏è Nettoyage : compte auth sera supprim√© par cascade ou RLS');
                throw profileError;
            }
            
            console.log('‚úÖ Profil cr√©√©:', profileDataResult.id);

            await fetchUsers();

            // √âmettre l'√©v√©nement pour notifier les autres composants
            if (window.EventBus && window.EventBusEvents) {
                window.EventBus.emit(window.EventBusEvents.USER_CREATED, {
                    userId: profileDataResult.id,
                    user: profileDataResult,
                    timestamp: new Date().toISOString()
                });
            }

            return profileDataResult;
        } catch (err) {
            console.error('üí• Erreur finale cr√©ation utilisateur:', err);
            setError(err.message);
            throw err;
        }
    };
    
    const updateUser = async (id, updates) => {
        try {
            setError(null);
            const { data, error: updateError } = await supabase
                .from('user_profile')
                .update(updates)
                .eq('id', id)
                .select()
                .single();

            if (updateError) throw updateError;

            await fetchUsers();

            // √âmettre l'√©v√©nement pour notifier les autres composants
            if (window.EventBus && window.EventBusEvents) {
                window.EventBus.emit(window.EventBusEvents.USER_UPDATED, {
                    userId: data.id,
                    user: data,
                    timestamp: new Date().toISOString()
                });
            }

            return data;
        } catch (err) {
            console.error('Erreur lors de la mise √† jour:', err);
            setError(err.message);
            throw err;
        }
    };
    
    const deleteUser = async (id) => {
        try {
            setError(null);
            
            // Suppression en cascade pour √©viter les erreurs de contraintes de cl√©s √©trang√®res
            console.log(`üóëÔ∏è D√©but suppression utilisateur ${id}`);
            
            // 1. Supprimer les comp√©tences utilisateur
            console.log('üóëÔ∏è Suppression des comp√©tences...');
            const { error: competencesError } = await supabase
                .from('user_competence')
                .delete()
                .eq('user_id', id);
            
            if (competencesError) {
                console.error('Erreur suppression comp√©tences:', competencesError);
                throw new Error(`Erreur lors de la suppression des comp√©tences: ${competencesError.message}`);
            }
            
            // 2. Supprimer les √©v√©nements de planning
            console.log('üóëÔ∏è Suppression des √©v√©nements de planning...');
            const { error: evenementsError } = await supabase
                .from('evenement')
                .delete()
                .eq('user_id', id);
            
            if (evenementsError) {
                console.error('Erreur suppression √©v√©nements:', evenementsError);
                throw new Error(`Erreur lors de la suppression des √©v√©nements: ${evenementsError.message}`);
            }
            
            // 3. Retirer l'utilisateur de la liste des stagiaires des projets
            console.log('üóëÔ∏è Mise √† jour des projets (suppression des listes de stagiaires)...');
            const { data: projectsWithUser, error: projectsSelectError } = await supabase
                .from('projects')
                .select('id, stagiaire_ids')
                .contains('stagiaire_ids', [id]);

            if (projectsSelectError) {
                console.error('Erreur s√©lection projets:', projectsSelectError);
                throw new Error(`Erreur lors de la recherche des projets: ${projectsSelectError.message}`);
            }

            // Mettre √† jour chaque projet pour retirer l'utilisateur de la liste des stagiaires
            if (projectsWithUser && projectsWithUser.length > 0) {
                for (const project of projectsWithUser) {
                    const updatedStagiaires = (project.stagiaire_ids || []).filter(stagiaireId => stagiaireId !== id);

                    const { error: projectUpdateError } = await supabase
                        .from('projects')
                        .update({ stagiaire_ids: updatedStagiaires })
                        .eq('id', project.id);

                    if (projectUpdateError) {
                        console.error(`Erreur mise √† jour projet ${project.id}:`, projectUpdateError);
                        throw new Error(`Erreur lors de la mise √† jour du projet ${project.id}: ${projectUpdateError.message}`);
                    }
                }
                console.log(`‚úÖ ${projectsWithUser.length} projet(s) mis √† jour`);
            }
            
            // 4. Supprimer les √©v√©nements o√π l'utilisateur est dans client_user_id
            console.log('üóëÔ∏è Mise √† jour des √©v√©nements (suppression des listes client_user_id)...');
            const { data: eventsWithUser, error: eventsSelectError } = await supabase
                .from('evenement')
                .select('id, client_user_id')
                .contains('client_user_id', [id]);
            
            if (eventsSelectError) {
                console.error('Erreur s√©lection √©v√©nements:', eventsSelectError);
                throw new Error(`Erreur lors de la recherche des √©v√©nements: ${eventsSelectError.message}`);
            }
            
            // Mettre √† jour chaque √©v√©nement pour retirer l'utilisateur de la liste client_user_id
            if (eventsWithUser && eventsWithUser.length > 0) {
                for (const event of eventsWithUser) {
                    const updatedClientUserIds = (event.client_user_id || []).filter(clientId => clientId !== id);
                    
                    const { error: eventUpdateError } = await supabase
                        .from('evenement')
                        .update({ client_user_id: updatedClientUserIds })
                        .eq('id', event.id);
                    
                    if (eventUpdateError) {
                        console.error(`Erreur mise √† jour √©v√©nement ${event.id}:`, eventUpdateError);
                        throw new Error(`Erreur lors de la mise √† jour de l'√©v√©nement ${event.id}: ${eventUpdateError.message}`);
                    }
                }
                console.log(`‚úÖ ${eventsWithUser.length} √©v√©nement(s) mis √† jour`);
            }
            
            // 5. Mettre √† jour les projets o√π l'utilisateur est contact
            console.log('üóëÔ∏è Mise √† jour des projets (suppression contact_id)...');
            const { data: projectsAsContact, error: projectsContactSelectError } = await supabase
                .from('projects')
                .select('id, name')
                .eq('contact_id', id);
            
            if (projectsContactSelectError) {
                console.error('Erreur s√©lection projets (contact):', projectsContactSelectError);
                throw new Error(`Erreur lors de la recherche des projets (contact): ${projectsContactSelectError.message}`);
            }
            
            if (projectsAsContact && projectsAsContact.length > 0) {
                const { error: projectsContactUpdateError } = await supabase
                    .from('projects')
                    .update({ contact_id: null })
                    .eq('contact_id', id);
                
                if (projectsContactUpdateError) {
                    console.error('Erreur mise √† jour projets (contact):', projectsContactUpdateError);
                    throw new Error(`Erreur lors de la mise √† jour des projets (contact): ${projectsContactUpdateError.message}`);
                }
                console.log(`‚úÖ ${projectsAsContact.length} projet(s) mis √† jour (contact retir√©)`);
            }
            
            // 6. Mettre √† jour les projets o√π l'utilisateur est commercial
            console.log('üóëÔ∏è Mise √† jour des projets (suppression commercial_id)...');
            const { data: projectsAsCommercial, error: projectsCommercialSelectError } = await supabase
                .from('projects')
                .select('id, name')
                .eq('commercial_id', id);
            
            if (projectsCommercialSelectError) {
                console.error('Erreur s√©lection projets (commercial):', projectsCommercialSelectError);
                throw new Error(`Erreur lors de la recherche des projets (commercial): ${projectsCommercialSelectError.message}`);
            }
            
            if (projectsAsCommercial && projectsAsCommercial.length > 0) {
                const { error: projectsCommercialUpdateError } = await supabase
                    .from('projects')
                    .update({ commercial_id: null })
                    .eq('commercial_id', id);
                
                if (projectsCommercialUpdateError) {
                    console.error('Erreur mise √† jour projets (commercial):', projectsCommercialUpdateError);
                    throw new Error(`Erreur lors de la mise √† jour des projets (commercial): ${projectsCommercialUpdateError.message}`);
                }
                console.log(`‚úÖ ${projectsAsCommercial.length} projet(s) mis √† jour (commercial retir√©)`);
            }
            
            // 7. Mettre √† jour les comp√©tences o√π l'utilisateur est √©valuateur
            console.log('üóëÔ∏è Mise √† jour des comp√©tences (suppression evaluateur_id)...');
            const { data: competencesAsEvaluateur, error: competencesEvaluateurSelectError } = await supabase
                .from('user_competence')
                .select('id')
                .eq('evaluateur_id', id);
            
            if (competencesEvaluateurSelectError) {
                console.error('Erreur s√©lection comp√©tences (√©valuateur):', competencesEvaluateurSelectError);
                throw new Error(`Erreur lors de la recherche des comp√©tences (√©valuateur): ${competencesEvaluateurSelectError.message}`);
            }
            
            if (competencesAsEvaluateur && competencesAsEvaluateur.length > 0) {
                const { error: competencesEvaluateurUpdateError } = await supabase
                    .from('user_competence')
                    .update({ evaluateur_id: null })
                    .eq('evaluateur_id', id);
                
                if (competencesEvaluateurUpdateError) {
                    console.error('Erreur mise √† jour comp√©tences (√©valuateur):', competencesEvaluateurUpdateError);
                    throw new Error(`Erreur lors de la mise √† jour des comp√©tences (√©valuateur): ${competencesEvaluateurUpdateError.message}`);
                }
                console.log(`‚úÖ ${competencesAsEvaluateur.length} comp√©tence(s) mise(s) √† jour (√©valuateur retir√©)`);
            }
            
            // 8. Mettre √† jour les t√¢ches o√π l'utilisateur est assign√©
            console.log('üóëÔ∏è Mise √† jour des t√¢ches (suppression assigned_to)...');
            const { data: tasksAssigned, error: tasksAssignedSelectError } = await supabase
                .from('tasks')
                .select('id, title')
                .eq('assigned_to', id);
            
            if (tasksAssignedSelectError) {
                console.error('Erreur s√©lection t√¢ches (assign√©):', tasksAssignedSelectError);
                throw new Error(`Erreur lors de la recherche des t√¢ches (assign√©): ${tasksAssignedSelectError.message}`);
            }
            
            if (tasksAssigned && tasksAssigned.length > 0) {
                const { error: tasksAssignedUpdateError } = await supabase
                    .from('tasks')
                    .update({ assigned_to: null })
                    .eq('assigned_to', id);
                
                if (tasksAssignedUpdateError) {
                    console.error('Erreur mise √† jour t√¢ches (assign√©):', tasksAssignedUpdateError);
                    throw new Error(`Erreur lors de la mise √† jour des t√¢ches (assign√©): ${tasksAssignedUpdateError.message}`);
                }
                console.log(`‚úÖ ${tasksAssigned.length} t√¢che(s) mise(s) √† jour (assignation retir√©e)`);
            }
            
            // 9. Mettre √† jour les t√¢ches cr√©√©es par l'utilisateur
            console.log('üóëÔ∏è Mise √† jour des t√¢ches (suppression created_by)...');
            const { data: tasksCreated, error: tasksCreatedSelectError } = await supabase
                .from('tasks')
                .select('id, title')
                .eq('created_by', id);
            
            if (tasksCreatedSelectError) {
                console.error('Erreur s√©lection t√¢ches (cr√©ateur):', tasksCreatedSelectError);
                throw new Error(`Erreur lors de la recherche des t√¢ches (cr√©ateur): ${tasksCreatedSelectError.message}`);
            }
            
            if (tasksCreated && tasksCreated.length > 0) {
                const { error: tasksCreatedUpdateError } = await supabase
                    .from('tasks')
                    .update({ created_by: null })
                    .eq('created_by', id);
                
                if (tasksCreatedUpdateError) {
                    console.error('Erreur mise √† jour t√¢ches (cr√©ateur):', tasksCreatedUpdateError);
                    throw new Error(`Erreur lors de la mise √† jour des t√¢ches (cr√©ateur): ${tasksCreatedUpdateError.message}`);
                }
                console.log(`‚úÖ ${tasksCreated.length} t√¢che(s) mise(s) √† jour (cr√©ateur retir√©)`);
            }
            
            // 10. Finalement, supprimer le profil utilisateur
            console.log('üóëÔ∏è Suppression du profil utilisateur...');
            const { error: deleteError } = await supabase
                .from('user_profile')
                .delete()
                .eq('id', id);
            
            if (deleteError) {
                console.error('Erreur suppression profil:', deleteError);
                throw new Error(`Erreur lors de la suppression du profil: ${deleteError.message}`);
            }
            
            console.log('‚úÖ Utilisateur supprim√© avec succ√®s');
            await fetchUsers();

            // √âmettre l'√©v√©nement pour notifier les autres composants
            if (window.EventBus && window.EventBusEvents) {
                window.EventBus.emit(window.EventBusEvents.USER_DELETED, {
                    userId: id,
                    timestamp: new Date().toISOString()
                });
            }

        } catch (err) {
            console.error('Erreur lors de la suppression:', err);
            setError(err.message);
            throw err;
        }
    };
    
    // R√©cup√©rer les utilisateurs d'une entreprise sp√©cifique
    const getUsersByEntreprise = useCallback(async (entrepriseId) => {
        try {
            if (!entrepriseId) return [];
            
            const { data, error: fetchError } = await supabase
                .from('user_profile')
                .select(`
                    id,
                    prenom,
                    nom,
                    email,
                    entreprise:entreprise_id(id, nom),
                    service:service_id(id, nom),
                    fonction:fonction_id(id, nom)
                `)
                .eq('entreprise_id', entrepriseId)
                .order('prenom', { ascending: true });
            
            if (fetchError) throw fetchError;
            return data || [];
        } catch (err) {
            console.error('Erreur lors du chargement des utilisateurs d\'entreprise:', err);
            return [];
        }
    }, []);

    // R√©soudre automatiquement un service par nom (cr√©er si n'existe pas)
    const resolveServiceByName = async (serviceName) => {
        if (!serviceName || serviceName.trim() === '') return null;
        
        const nom = serviceName.trim();
        
        // Chercher le service existant
        const { data: existingService, error: searchError } = await supabase
            .from('service')
            .select('id, nom')
            .ilike('nom', nom)
            .single();
        
        if (searchError && searchError.code !== 'PGRST116') {
            throw searchError;
        }
        
        if (existingService) {
            return existingService.id;
        }
        
        // Cr√©er le nouveau service
        const { data: newService, error: createError } = await supabase
            .from('service')
            .insert({ nom })
            .select('id')
            .single();
        
        if (createError) throw createError;
        return newService.id;
    };

    // R√©soudre automatiquement une fonction par nom (cr√©er si n'existe pas)
    const resolveFonctionByName = async (fonctionName) => {
        if (!fonctionName || fonctionName.trim() === '') return null;
        
        const nom = fonctionName.trim();
        
        // Chercher la fonction existante
        const { data: existingFonction, error: searchError } = await supabase
            .from('fonction')
            .select('id, nom')
            .ilike('nom', nom)
            .single();
        
        if (searchError && searchError.code !== 'PGRST116') {
            throw searchError;
        }
        
        if (existingFonction) {
            return existingFonction.id;
        }
        
        // Cr√©er la nouvelle fonction
        const { data: newFonction, error: createError } = await supabase
            .from('fonction')
            .insert({ nom })
            .select('id')
            .single();
        
        if (createError) throw createError;
        return newFonction.id;
    };

    // Obtenir l'entreprise Arkance (type interne)
    const getArkanceEntreprise = async () => {
        const { data: arkanceEntreprise, error } = await supabase
            .from('entreprise')
            .select('id')
            .eq('type_entreprise', 'interne')
            .single();
        
        if (error) throw new Error('Impossible de trouver l\'entreprise Arkance (type interne)');
        return arkanceEntreprise.id;
    };

    // Import en lot des utilisateurs depuis CSV
    const importUsersFromCSV = async (csvData, progressCallback) => {
        const results = { success: [], errors: [] };
        
        try {
            // Obtenir l'ID de l'entreprise Arkance
            const arkanceEntrepriseId = await getArkanceEntreprise();
            
            for (let i = 0; i < csvData.length; i++) {
                const userData = csvData[i];
                
                try {
                    // Appeler le callback de progression
                    if (progressCallback) {
                        progressCallback({ current: i, total: csvData.length });
                    }
                    
                    // R√©soudre le service et la fonction
                    const serviceId = await resolveServiceByName(userData.service);
                    const fonctionId = await resolveFonctionByName(userData.fonction);
                    
                    // Pr√©parer les donn√©es utilisateur compl√®tes
                    const completeUserData = {
                        nom: userData.nom,
                        prenom: userData.prenom,
                        email: userData.email,
                        telephone: userData.telephone,
                        password: userData.motDePasse,
                        role: userData.role,
                        entreprise_id: arkanceEntrepriseId,
                        service_id: serviceId,
                        fonction_id: fonctionId
                    };
                    
                    // Cr√©er l'utilisateur avec auth
                    const createdUser = await createUserWithAuth(completeUserData);
                    
                    results.success.push({
                        line: userData._lineNumber,
                        nom: userData.nom,
                        prenom: userData.prenom,
                        email: userData.email,
                        id: createdUser.id
                    });
                    
                } catch (userError) {
                    console.error(`Erreur import ligne ${userData._lineNumber}:`, userError);
                    results.errors.push({
                        line: userData._lineNumber,
                        nom: userData.nom,
                        prenom: userData.prenom,
                        email: userData.email,
                        error: userError.message || 'Erreur inconnue'
                    });
                }
            }
            
            // Callback final de progression
            if (progressCallback) {
                progressCallback({ current: csvData.length, total: csvData.length });
            }
            
        } catch (globalError) {
            console.error('Erreur globale lors de l\'import:', globalError);
            throw new Error(`Erreur globale: ${globalError.message}`);
        }
        
        return results;
    };
    
    useEffect(() => {
        fetchUsers();
    }, [fetchUsers]);
    
    return { 
        users, 
        loading, 
        error, 
        createUser, 
        createUserWithAuth,
        updateUser, 
        deleteUser, 
        refetch: fetchUsers,
        getUsersByEntreprise,
        importUsersFromCSV,
        resolveServiceByName,
        resolveFonctionByName
    };
}

// Export global
window.useUsers = useUsers;