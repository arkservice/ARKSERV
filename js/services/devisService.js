// Service pour la gestion de la logique des devis (upload et signature)
function useDevisService() {
    const { useState, useCallback, useMemo } = React;
    const supabase = window.supabaseConfig.client;
    const { autoCompleteDevisTask, autoCompleteValidationTask } = window.useTasks();

    // √âtats sp√©cifiques aux devis
    const [uploadingFile, setUploadingFile] = useState(false);
    const [fileInputKey, setFileInputKey] = useState(0);
    const [showSignaturePad, setShowSignaturePad] = useState(false);
    const [signing, setSigning] = useState(false);
    const [signaturePosition, setSignaturePosition] = useState(null);
    const [capturedSignature, setCapturedSignature] = useState(null);
    const [signatureStep, setSignatureStep] = useState('position'); // 'position', 'capture', 'preview'

    // Fonction pour g√©rer l'upload du fichier de devis
    const handleFileUpload = useCallback(async (event, tache, onNavigateToProject, setTache) => {
        const file = event.target.files[0];
        if (!file) return;
        
        // V√©rifier le type de fichier
        const allowedTypes = ['application/pdf'];
        if (!allowedTypes.includes(file.type)) {
            alert('Seuls les fichiers PDF sont autoris√©s pour les devis.');
            setFileInputKey(prev => prev + 1);
            return;
        }
        
        try {
            setUploadingFile(true);
            
            // Nom de fichier unique
            const fileName = `devis_${tache.project.id}_${Date.now()}.pdf`;
            
            // Upload vers Supabase Storage
            const { data: uploadData, error: uploadError } = await supabase.storage
                .from('avatars')
                .upload(fileName, file, {
                    contentType: 'application/pdf',
                    cacheControl: '3600',
                    upsert: true
                });
            
            if (uploadError) {
                throw new Error(`Erreur upload: ${uploadError.message}`);
            }
            
            // Obtenir l'URL publique
            const { data } = supabase.storage.from('avatars').getPublicUrl(fileName);
            const publicUrl = data.publicUrl;
            
            // Mettre √† jour le projet avec l'URL du devis
            const { error: updateError } = await supabase
                .from('projects')
                .update({ pdf_devis: publicUrl })
                .eq('id', tache.project.id);
            
            if (updateError) {
                throw new Error(`Erreur mise √† jour: ${updateError.message}`);
            }
            
            // Auto-compl√©ter la t√¢che "Devis" si c'est la t√¢che actuelle
            let shouldComplete = false;
            let completionMessage = 'Devis upload√© avec succ√®s !';
            
            if (tache.title === "Devis" && tache.workflow_order === 3) {
                try {
                    await autoCompleteDevisTask(tache.project.id, publicUrl);
                    console.log("‚úÖ T√¢che 'Devis' automatiquement marqu√©e comme termin√©e");
                    shouldComplete = true;
                    completionMessage = 'Devis upload√© avec succ√®s ! La t√¢che a √©t√© automatiquement marqu√©e comme termin√©e et la t√¢che "Validation du devis" est maintenant accessible.';
                    
                    if (onNavigateToProject) {
                        setTimeout(() => {
                            onNavigateToProject(tache.project.id, tache.id);
                        }, 500);
                    }
                } catch (autoCompleteError) {
                    console.error('Erreur lors de l\'auto-compl√©tion:', autoCompleteError);
                    completionMessage = 'Devis upload√© avec succ√®s ! Cependant, la t√¢che n\'a pas pu √™tre automatiquement marqu√©e comme termin√©e.';
                }
            }
            
            // Mettre √† jour l'√©tat de la t√¢che
            setTache(prev => ({
                ...prev,
                project: {
                    ...prev.project,
                    pdf_devis: publicUrl
                },
                ...(shouldComplete && {
                    status: 'completed',
                    description: 'Devis upload√© avec succ√®s. Document disponible en pi√®ce jointe.'
                })
            }));
            
            setFileInputKey(prev => prev + 1);
            
        } catch (error) {
            console.error('Erreur lors de l\'upload:', error);
            alert('Erreur lors de l\'upload du devis: ' + error.message);
            setFileInputKey(prev => prev + 1);
        } finally {
            setUploadingFile(false);
        }
    }, [autoCompleteDevisTask]);

    // Fonction pour t√©l√©charger le devis existant
    const handleDownloadDevis = useCallback((tache) => {
        if (tache.project?.pdf_devis) {
            window.open(tache.project.pdf_devis, '_blank');
        }
    }, []);

    // Fonction pour t√©l√©charger le devis sign√©
    const handleDownloadSignedDevis = useCallback((tache) => {
        if (tache.project?.pdf_devis_signe) {
            window.open(tache.project.pdf_devis_signe, '_blank');
        }
    }, []);

    // Fonction pour d√©marrer le processus de signature
    const startSigningProcess = useCallback(() => {
        setSignatureStep('position');
        setSignaturePosition(null);
        setCapturedSignature(null);
    }, []);

    // Fonction appel√©e quand l'utilisateur clique sur le PDF pour positionner la signature
    const handleSignaturePositioned = useCallback((position) => {
        setSignaturePosition(position);
        setSignatureStep('capture');
        setShowSignaturePad(true);
    }, []);

    // Fonction pour capturer la signature depuis le SignaturePad
    const handleSignatureCaptured = useCallback((signatureDataURL) => {
        setCapturedSignature(signatureDataURL);
        setShowSignaturePad(false);
        setSignatureStep('preview');
        console.log('‚úÖ Signature captur√©e et affich√©e instantan√©ment sur le PDF');
    }, []);

    // Fonction pour finaliser la signature et cr√©er le PDF sign√©
    const finalizeSignature = useCallback(async (tache, onNavigateToProject, setTache) => {
        if (!signaturePosition || !capturedSignature) {
            alert('Position ou signature manquante');
            return;
        }
        await handleSignDocument(capturedSignature, tache, onNavigateToProject, setTache);
    }, [signaturePosition, capturedSignature]);

    // Fonction pour annuler le processus de signature
    const cancelSigning = useCallback(() => {
        setSignatureStep('position');
        setSignaturePosition(null);
        setCapturedSignature(null);
        setShowSignaturePad(false);
    }, []);

    // Fonction pour capturer la signature et signer le PDF
    const handleSignDocument = useCallback(async (signatureDataURL, tache, onNavigateToProject, setTache) => {
        if (!tache.project?.pdf_devis || !signatureDataURL || !signaturePosition) {
            console.error('PDF du devis, signature ou position manquante');
            return;
        }

        try {
            setSigning(true);
            
            // Valider les donn√©es avant traitement
            window.PDFSigner.validateSignatureData(signatureDataURL);
            window.PDFSigner.validateSignaturePosition(signaturePosition);
            
            console.log('üîß Cr√©ation du PDF sign√© avec PDF-lib...');
            
            // Cr√©er le PDF sign√© avec PDF-lib
            const signedPdfBlob = await window.PDFSigner.createSignedPDF(
                tache.project.pdf_devis,
                signatureDataURL,
                signaturePosition
            );
            
            console.log('‚úÖ PDF sign√© cr√©√© avec succ√®s');
            
            // Nom de fichier unique pour le PDF sign√©
            const signedFileName = `devis_signe_${tache.project.id}_${Date.now()}.pdf`;
            
            // Upload du PDF sign√© vers Supabase Storage
            const { data: uploadData, error: uploadError } = await supabase.storage
                .from('avatars')
                .upload(signedFileName, signedPdfBlob, {
                    contentType: 'application/pdf',
                    cacheControl: '3600',
                    upsert: true
                });
            
            if (uploadError) {
                throw new Error(`Erreur upload: ${uploadError.message}`);
            }
            
            // Obtenir l'URL publique du PDF sign√©
            const { data } = supabase.storage.from('avatars').getPublicUrl(signedFileName);
            const signedPdfUrl = data.publicUrl;
            
            // Mettre √† jour le projet avec l'URL du devis sign√©
            const { error: updateError } = await supabase
                .from('projects')
                .update({ pdf_devis_signe: signedPdfUrl })
                .eq('id', tache.project.id);
            
            if (updateError) {
                throw new Error(`Erreur mise √† jour: ${updateError.message}`);
            }
            
            // Mettre √† jour l'√©tat local du projet
            setTache(prev => ({
                ...prev,
                project: {
                    ...prev.project,
                    pdf_devis_signe: signedPdfUrl
                }
            }));
            
            // Auto-compl√©ter la t√¢che si c'est une validation
            if (tache.title === "Validation du devis" && tache.workflow_order === 4) {
                try {
                    await autoCompleteValidationTask(tache.project.id, signedPdfUrl);
                    
                    setTache(prev => ({
                        ...prev,
                        status: 'completed',
                        description: 'Devis valid√© et sign√© √©lectroniquement par le client. Document sign√© disponible.'
                    }));
                    
                    if (onNavigateToProject) {
                        setTimeout(() => {
                            onNavigateToProject(tache.project.id, tache.id);
                        }, 2000);
                    }
                } catch (autoCompleteError) {
                    console.error('Erreur lors de l\'auto-compl√©tion de la validation:', autoCompleteError);
                }
                
                console.log('Document sign√© avec succ√®s !');
            }
            
            // R√©initialiser le workflow de signature
            setSignatureStep('position');
            setShowSignaturePad(false);
            setSignaturePosition(null);
            setCapturedSignature(null);
            console.log('‚úÖ √âtats de signature r√©initialis√©s');
            
        } catch (error) {
            console.error('Erreur lors de la signature:', error);
            alert('Erreur lors de la signature du document: ' + error.message);
        } finally {
            setSigning(false);
        }
    }, [signaturePosition, autoCompleteValidationTask]);

    // M√©moriser l'URL du PDF pour √©viter les re-rendus inutiles
    const getStablePdfUrl = useCallback((tache) => {
        return tache?.project?.pdf_devis;
    }, []);

    // Fonction pour obtenir les signatures √† afficher sur le PDF
    const getSignaturesForViewer = useCallback((tache) => {
        if (capturedSignature && signaturePosition && !tache.project?.pdf_devis_signe) {
            return [{
                page: signaturePosition.page,
                x: signaturePosition.x,
                y: signaturePosition.y,
                width: signaturePosition.width,
                height: signaturePosition.height,
                imageData: capturedSignature
            }];
        }
        return [];
    }, [capturedSignature, signaturePosition]);

    // Fonction pour d√©terminer si le PDF est en lecture seule
    const isPdfReadOnly = useCallback((tache) => {
        return !!tache.project?.pdf_devis_signe;
    }, []);

    // Fonction pour r√©initialiser les √©tats des devis
    const resetDevisState = useCallback(() => {
        setUploadingFile(false);
        setFileInputKey(0);
        setShowSignaturePad(false);
        setSigning(false);
        setSignaturePosition(null);
        setCapturedSignature(null);
        setSignatureStep('position');
    }, []);

    return {
        // √âtats
        uploadingFile,
        fileInputKey,
        showSignaturePad,
        signing,
        signaturePosition,
        capturedSignature,
        signatureStep,
        
        // Actions
        setUploadingFile,
        setFileInputKey,
        setShowSignaturePad,
        setSigning,
        setSignaturePosition,
        setCapturedSignature,
        setSignatureStep,
        
        // Fonctions
        handleFileUpload,
        handleDownloadDevis,
        handleDownloadSignedDevis,
        startSigningProcess,
        handleSignaturePositioned,
        handleSignatureCaptured,
        finalizeSignature,
        cancelSigning,
        handleSignDocument,
        getStablePdfUrl,
        getSignaturesForViewer,
        isPdfReadOnly,
        resetDevisState
    };
}

// Export global
window.useDevisService = useDevisService;